/**
 * @file query-utils.ts
 * @description This file contains the `QueryManager` class, which provides a set of utilities
 * for querying the Concrete Syntax Tree (CST) generated by Tree-sitter. It simplifies the
 * process of finding specific nodes, executing queries, and extracting information from the CST.
 *
 * @architectural_decision
 * The `QueryManager` is designed as a stateful utility that encapsulates the Tree-sitter parser,
 * language, and the current syntax tree. This approach allows for a more streamlined and
 * efficient way to work with the CST, as the parser and language do not need to be passed
 * around to different functions. The class also includes a query cache to avoid recompiling
 * the same queries multiple times, which can be a performance bottleneck.
 *
 * @example
 * ```typescript
 * import { QueryManager } from './query-utils';
 * import { Parser, Language } from 'web-tree-sitter';
 *
 * async function main() {
 *   // 1. Setup parser and language
 *   await Parser.init();
 *   const parser = new Parser();
 *   const openscadLanguage = await Language.load('tree-sitter-openscad.wasm');
 *   parser.setLanguage(openscadLanguage);
 *
 *   // 2. Create a new QueryManager instance
 *   const queryManager = new QueryManager(parser, openscadLanguage, 'path/to/queries');
 *
 *   // 3. Parse some source code
 *   const sourceCode = 'module my_module() { cube(10); }';
 *   queryManager.parse(sourceCode);
 *
 *   // 4. Find all module definitions
 *   const moduleDefinitions = await queryManager.findModuleDefinitions();
 *   console.log(moduleDefinitions);
 * }
 *
 * main();
 * ```
 *
 * @integration
 * The `QueryManager` is used by various visitors in the parser to query the CST for specific
 * nodes and patterns. For example, the `ModuleVisitor` might use it to find all module
 * definitions, and the `FunctionVisitor` might use it to find all function calls. This
 * utility is a key part of the CST processing pipeline.
 */

import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import {
  type Language,
  type Parser,
  Query,
  type QueryMatch,
  type Tree,
  type Node as TSNode,
} from 'web-tree-sitter';

// Type definitions for OpenSCAD specific nodes
// Type alias for tree-sitter Node
type OpenSCADNode = TSNode;

export interface QueryResult {
  patternIndex: number;
  captures: Array<{
    name: string;
    node: TSNode;
    text: string;
    start: { row: number; column: number };
    end: { row: number; column: number };
  }>;
}

export class QueryManager {
  private queryCache: Map<string, Query> = new Map();
  private parser: Parser;
  private language: Language; // Tree-sitter Language
  private queryDir: string;
  private tree: Tree | undefined;

  constructor(parser: Parser, language: Language, queryDir: string) {
    this.parser = parser;
    this.language = language;
    this.queryDir = queryDir;
    this.tree = undefined;
  }

  /**
   * @method parse
   * @description Parses source code and stores the syntax tree.
   * @param {string} source - The source code to parse.
   * @returns {Tree} The parsed syntax tree.
   */
  public parse(source: string): Tree {
    const tree = this.parser.parse(source);
    if (!tree) {
      throw new Error('Failed to parse source code');
    }
    this.tree = tree;
    return tree;
  }

  /**
   * @method getRootNode
   * @description Gets the root node of the parsed tree.
   * @returns {TSNode | null} The root node, or null if no tree has been parsed.
   */
  public getRootNode(): TSNode | null {
    return this.tree?.rootNode || null;
  }

  /**
   * @method loadQuery
   * @description Loads and compiles a query from a file.
   * @param {string} name - The name of the query to load.
   * @returns {Promise<Query>} A promise that resolves with the compiled query.
   */
  public async loadQuery(name: string): Promise<Query> {
    if (this.queryCache.has(name)) {
      const cachedQuery = this.queryCache.get(name);
      if (!cachedQuery) {
        throw new Error(`Query ${name} not found in cache`);
      }
      return cachedQuery;
    }

    try {
      const queryPath = path.join(this.queryDir, `${name}.scm`);
      const querySource = await fs.readFile(queryPath, 'utf-8');
      const query = new Query(this.language, querySource);
      this.queryCache.set(name, query);
      return query;
    } catch (error) {
      throw new Error(
        `Failed to load query '${name}': ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * @method queryTree
   * @description Executes a query on the current tree.
   * @param {string} queryName - The name of the query to execute.
   * @returns {QueryResult[]} An array of query results.
   */
  public queryTree(queryName: string): QueryResult[] {
    if (!this.tree) {
      throw new Error('No tree parsed. Call parse() first.');
    }
    return this.queryNode(queryName, this.tree.rootNode);
  }

  /**
   * @method queryNode
   * @description Executes a query on a specific node.
   * @param {string} queryName - The name of the query to execute.
   * @param {TSNode} node - The node to query.
   * @returns {QueryResult[]} An array of query results.
   */
  public queryNode(queryName: string, node: TSNode): QueryResult[] {
    const query = this.queryCache.get(queryName);
    if (!query) {
      throw new Error(`Query '${queryName}' not loaded. Call loadQuery() first.`);
    }

    const matches = query.matches(node);
    return matches.map((match) => this.processQueryMatch(match, query));
  }

  /**
   * @method findModuleDefinitions
   * @description Finds all module definitions in the current tree.
   * @returns {Promise<TSNode[]>} A promise that resolves with an array of module definition nodes.
   */
  public async findModuleDefinitions(): Promise<TSNode[]> {
    await this.loadQuery('highlights');
    const results = this.queryTree('highlights');
    return results
      .filter((result) => result.captures.some((c) => c.name === 'module_definition'))
      .map((result) => result.captures.find((c) => c.name === 'module_name')?.node)
      .filter((node): node is OpenSCADNode => node !== undefined);
  }

  /**
   * @method findFunctionDefinitions
   * @description Finds all function definitions in the current tree.
   * @returns {Promise<TSNode[]>} A promise that resolves with an array of function definition nodes.
   */
  public async findFunctionDefinitions(): Promise<TSNode[]> {
    await this.loadQuery('highlights');
    const results = this.queryTree('highlights');
    return results
      .filter((result) => result.captures.some((c) => c.name === 'function_definition'))
      .map((result) => result.captures.find((c) => c.name === 'function_name')?.node)
      .filter((node): node is OpenSCADNode => node !== undefined);
  }

  /**
   * @method findDependencies
   * @description Finds all include and use statements in the current tree.
   * @returns {Promise<{ file: string; type: 'include' | 'use' }[]>} A promise that resolves with an array of dependencies.
   */
  public async findDependencies(): Promise<{ file: string; type: 'include' | 'use' }[]> {
    await this.loadQuery('dependencies');
    const results = this.queryTree('dependencies');

    const dependencies: { file: string; type: 'include' | 'use' }[] = [];

    for (const result of results) {
      const includeMatch = result.captures.find((c) => c.name === 'include');
      const useMatch = result.captures.find((c) => c.name === 'use');
      const fileMatch = result.captures.find((c) => c.name === 'file_path');

      if (includeMatch && fileMatch?.node.text) {
        dependencies.push({
          file: fileMatch.node.text.replace(/^["']|["']$/g, ''),
          type: 'include',
        });
      } else if (useMatch && fileMatch?.node.text) {
        dependencies.push({
          file: fileMatch.node.text.replace(/^["']|["']$/g, ''),
          type: 'use',
        });
      }
    }

    return dependencies;
  }

  /**
   * @method findAllNodesOfType
   * @description Finds all nodes of a specific type in the current tree.
   * @param {string | string[]} type - The type or types of nodes to find.
   * @returns {TSNode[]} An array of nodes of the specified type.
   */
  public findAllNodesOfType(type: string | string[]): TSNode[] {
    if (!this.tree) {
      throw new Error('No tree parsed. Call parse() first.');
    }

    const types = Array.isArray(type) ? type : [type];
    const nodes: TSNode[] = [];

    const visit = (node: TSNode): void => {
      if (types.includes(node.type)) {
        nodes.push(node);
      }

      for (let i = 0; i < node.childCount; i++) {
        const child = node.child(i);
        if (child) {
          visit(child);
        }
      }
    };

    visit(this.tree.rootNode);
    return nodes;
  }

  /**
   * @method findFirstNodeOfType
   * @description Finds the first node of a specific type in the current tree.
   * @param {string | string[]} type - The type or types of nodes to find.
   * @returns {TSNode | null} The first node of the specified type, or null if not found.
   */
  public findFirstNodeOfType(type: string | string[]): TSNode | null {
    if (!this.tree) {
      throw new Error('No tree parsed. Call parse() first.');
    }

    const types = Array.isArray(type) ? type : [type];

    const find = (node: TSNode): TSNode | null => {
      if (types.includes(node.type)) {
        return node;
      }

      for (let i = 0; i < node.childCount; i++) {
        const child = node.child(i);
        if (child) {
          const found = find(child);
          if (found) return found;
        }
      }

      return null;
    };

    return find(this.tree.rootNode);
  }

  /**
   * @method hasAncestorOfType
   * @description Checks if a node has an ancestor of a specific type.
   * @param {TSNode} node - The node to check.
   * @param {string | string[]} ancestorType - The type or types of ancestors to look for.
   * @returns {boolean} True if an ancestor of the specified type is found.
   */
  public hasAncestorOfType(node: TSNode, ancestorType: string | string[]): boolean {
    const types = Array.isArray(ancestorType) ? ancestorType : [ancestorType];
    let current = node.parent;

    while (current) {
      if (types.includes(current.type)) {
        return true;
      }
      current = current.parent;
    }

    return false;
  }

  /**
   * @method getNodeTextWithSemicolon
   * @description Gets the text of a node, including any trailing semicolon if present.
   * @param {TSNode} node - The node to get the text of.
   * @param {string} source - The source code.
   * @returns {string} The text of the node, with a trailing semicolon if present.
   */
  public getNodeTextWithSemicolon(node: TSNode, source: string): string {
    let text = node.text;

    // Check if there's a semicolon immediately after the node
    if (node.endIndex < source.length && source[node.endIndex] === ';') {
      text += ';';
    }

    return text;
  }

  /**
   * @method getNodeFullText
   * @description Gets the full text of the node including all its children.
   * @param {TSNode} node - The node to get the full text of.
   * @param {string} source - The source code.
   * @returns {string} The full text of the node.
   */
  public getNodeFullText(node: TSNode, source: string): string {
    return source.slice(node.startIndex, node.endIndex);
  }

  /**
   * @method getNodeLocation
   * @description Gets the location of a node in the source code.
   * @param {TSNode} node - The node to get the location of.
   * @returns {{ start: { line: number; column: number; index: number }; end: { line: number; column: number; index: number } }} The location of the node.
   */
  public getNodeLocation(node: TSNode): {
    start: { line: number; column: number; index: number };
    end: { line: number; column: number; index: number };
  } {
    return {
      start: {
        line: node.startPosition.row + 1,
        column: node.startPosition.column,
        index: node.startIndex,
      },
      end: {
        line: node.endPosition.row + 1,
        column: node.endPosition.column,
        index: node.endIndex,
      },
    };
  }

  /**
   * @method processQueryMatch
   * @description Processes a query match into a more usable format.
   * @param {QueryMatch} match - The query match to process.
   * @param {Query} _query - The query that was executed.
   * @returns {QueryResult} The processed query result.
   * @private
   */
  private processQueryMatch(match: QueryMatch, _query: Query): QueryResult {
    const captures = match.captures.map((capture, index) => {
      // Use the index as a fallback name if we can't determine the capture name

      return {
        name: `capture_${index}`, // Use the index as a fallback name if we can't determine the capture name
        node: capture.node,
        text: capture.node.text,
        start: capture.node.startPosition,
        end: capture.node.endPosition,
      };
    });

    return {
      patternIndex: match.patternIndex,
      captures,
    };
  }

  /**
   * @method getCapturesByName
   * @description Gets all captures with a specific name from query results.
   * @param {QueryResult[]} results - The query results to search.
   * @param {string | string[]} name - The name or names of the captures to get.
   * @returns {Array<{ node: TSNode; text: string; start: { row: number; column: number }; end: { row: number; column: number } }>} An array of captures.
   * @static
   */
  public static getCapturesByName(
    results: QueryResult[],
    name: string | string[]
  ): Array<{
    node: TSNode;
    text: string;
    start: { row: number; column: number };
    end: { row: number; column: number };
  }> {
    const names = Array.isArray(name) ? name : [name];
    const captures: Array<{
      node: TSNode;
      text: string;
      start: { row: number; column: number };
      end: { row: number; column: number };
    }> = [];

    for (const result of results) {
      for (const capture of result.captures) {
        if (names.includes(capture.name)) {
          captures.push({
            node: capture.node,
            text: capture.text,
            start: capture.node.startPosition,
            end: capture.node.endPosition,
          });
        }
      }
    }

    return captures;
  }

  /**
   * @method getSourceForRange
   * @description Gets the source code for a range.
   * @param {number} start - The start index of the range.
   * @param {number} end - The end index of the range.
   * @param {string} source - The source code.
   * @returns {string} The source code for the specified range.
   */
  public getSourceForRange(start: number, end: number, source: string): string {
    return source.slice(start, end);
  }

  /**
   * @method dispose
   * @description Disposes of resources used by the `QueryManager`.
   */
  public dispose(): void {
    this.queryCache.clear();
    this.tree = undefined;
  }
}
