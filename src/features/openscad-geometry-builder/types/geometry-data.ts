/**
 * @file geometry-data.ts
 * @description Core geometry data types for 3D primitives following OpenSCAD specifications.
 * These types represent the raw vertex and face data generated by OpenSCAD-compatible algorithms.
 *
 * @example
 * ```typescript
 * // Sphere geometry data for $fn=3
 * const sphereData: SphereGeometryData = {
 *   vertices: [
 *     { x: 3.536, y: 0, z: 3.536 },     // Ring 0, vertex 0
 *     { x: -1.768, y: 3.062, z: 3.536 }, // Ring 0, vertex 1
 *     { x: -1.768, y: -3.062, z: 3.536 }, // Ring 0, vertex 2
 *     { x: 3.536, y: 0, z: -3.536 },    // Ring 1, vertex 0
 *     { x: -1.768, y: 3.062, z: -3.536 }, // Ring 1, vertex 1
 *     { x: -1.768, y: -3.062, z: -3.536 } // Ring 1, vertex 2
 *   ],
 *   faces: [[0, 1, 4, 3], [1, 2, 5, 4], [2, 0, 3, 5]], // Quad faces
 *   normals: [...] // Computed normals
 * };
 * ```
 *
 * @author OpenSCAD Babylon Team
 * @version 1.0.0
 * @since 2025-07-29
 */

import type { Result } from '@/shared';
import { error, success } from '@/shared';

/**
 * 3D Vector representation matching OpenSCAD coordinate system (Z-up, right-handed)
 */
export interface Vector3 {
  x: number;
  y: number;
  z: number;
}

/**
 * 2D Vector representation for UV coordinates and 2D primitives
 */
export interface Vector2 {
  readonly x: number;
  readonly y: number;
}

/**
 * Base geometry data interface for all 3D primitives
 */
export interface BaseGeometryData {
  /** Array of vertex positions in 3D space */
  readonly vertices: readonly Vector3[];

  /** Array of face indices (triangles or quads) */
  readonly faces: readonly (readonly number[])[];

  /** Array of vertex normals for lighting calculations */
  readonly normals: readonly Vector3[];

  /** Optional UV coordinates for texture mapping */
  readonly uvs?: readonly Vector2[];

  /** Metadata about the geometry generation */
  readonly metadata: GeometryMetadata;
}

/**
 * Metadata about geometry generation for debugging and optimization
 */
export interface GeometryMetadata {
  /** Type of primitive that generated this geometry */
  readonly primitiveType: '3d-sphere' | '3d-cube' | '3d-cylinder' | '3d-polyhedron' | '3d-boolean-result';

  /** Parameters used to generate the geometry */
  readonly parameters: Record<string, unknown>;

  /** Fragment count used for tessellation */
  readonly fragmentCount?: number;

  /** Generation timestamp for caching */
  readonly generatedAt: number;

  /** Whether the geometry is convex (optimization hint) */
  readonly isConvex: boolean;

  /** Volume of the geometry in cubic units */
  readonly volume?: number;

  /** Surface area of the geometry in square units */
  readonly surfaceArea?: number;

  /** Bounding box of the geometry */
  readonly boundingBox?: {
    readonly min: Vector3;
    readonly max: Vector3;
  };

  /** Whether the geometry is valid (no self-intersections, etc.) */
  readonly isValid?: boolean;

  /** Time taken to generate the geometry in milliseconds */
  readonly generationTime?: number;

  /** Import statistics for imported geometry */
  readonly importStatistics?: {
    readonly format: string;
    readonly fileSize: number;
    readonly vertexCount: number;
    readonly faceCount: number;
    readonly parseTime: number;
    readonly totalTime: number;
  };
}

/**
 * Sphere geometry data with ring-based tessellation
 */
export interface SphereGeometryData extends BaseGeometryData {
  readonly metadata: GeometryMetadata & {
    readonly primitiveType: '3d-sphere';
    readonly parameters: {
      readonly radius: number;
      readonly fragments: number;
    };
  };
}

/**
 * Cube geometry data with 8 vertices and 6 faces
 */
export interface CubeGeometryData extends BaseGeometryData {
  readonly metadata: GeometryMetadata & {
    readonly primitiveType: '3d-cube';
    readonly parameters: {
      readonly size: Vector3;
      readonly center: boolean;
    };
  };
}

/**
 * Cylinder geometry data with circular cross-sections
 */
export interface CylinderGeometryData extends BaseGeometryData {
  readonly metadata: GeometryMetadata & {
    readonly primitiveType: '3d-cylinder';
    readonly parameters: {
      readonly height: number;
      readonly r1: number;
      readonly r2: number;
      readonly center: boolean;
      readonly fragments: number;
    };
  };
}

/**
 * Polyhedron geometry data with user-defined vertices and faces
 */
export interface PolyhedronGeometryData extends BaseGeometryData {
  readonly metadata: GeometryMetadata & {
    readonly primitiveType: '3d-polyhedron';
    readonly parameters: {
      readonly pointCount: number;
      readonly faceCount: number;
      readonly convexity: number;
    };
  };
}

/**
 * Union type for all 3D geometry data
 */
export type Geometry3DData =
  | SphereGeometryData
  | CubeGeometryData
  | CylinderGeometryData
  | PolyhedronGeometryData;

/**
 * Union type for all geometry data (2D and 3D)
 */
export type GeometryData = Geometry3DData | import('./2d-geometry-data').Geometry2DData;

/**
 * Bounding box for geometry optimization
 */
export interface BoundingBox3D {
  readonly min: Vector3;
  readonly max: Vector3;
  readonly center: Vector3;
  readonly size: Vector3;
}

/**
 * Error types for geometry generation
 */
export interface GeometryGenerationError {
  readonly type:
    | 'INVALID_PARAMETERS'
    | 'TESSELLATION_FAILED'
    | 'MEMORY_ERROR'
    | 'COMPUTATION_ERROR';
  readonly message: string;
  readonly details?: Record<string, unknown>;
}

/**
 * Result type for geometry generation operations
 */
export type GeometryResult<T extends BaseGeometryData> = Result<T, GeometryGenerationError>;

/**
 * Utility functions for geometry data manipulation
 */
export namespace GeometryUtils {
  /**
   * Calculate bounding box for geometry data
   */
  export function calculateBoundingBox(geometry: BaseGeometryData): BoundingBox3D {
    if (geometry.vertices.length === 0) {
      const zero = { x: 0, y: 0, z: 0 };
      return { min: zero, max: zero, center: zero, size: zero };
    }

    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let minZ = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    let maxZ = Number.NEGATIVE_INFINITY;

    for (const vertex of geometry.vertices) {
      minX = Math.min(minX, vertex.x);
      minY = Math.min(minY, vertex.y);
      minZ = Math.min(minZ, vertex.z);
      maxX = Math.max(maxX, vertex.x);
      maxY = Math.max(maxY, vertex.y);
      maxZ = Math.max(maxZ, vertex.z);
    }

    const min = { x: minX, y: minY, z: minZ };
    const max = { x: maxX, y: maxY, z: maxZ };
    const center = {
      x: (minX + maxX) / 2,
      y: (minY + maxY) / 2,
      z: (minZ + maxZ) / 2,
    };
    const size = {
      x: maxX - minX,
      y: maxY - minY,
      z: maxZ - minZ,
    };

    return { min, max, center, size };
  }

  /**
   * Validate geometry data integrity
   */
  export function validateGeometry(
    geometry: BaseGeometryData
  ): Result<void, GeometryGenerationError> {
    // Check for empty vertices
    if (geometry.vertices.length === 0) {
      return error({
        type: 'INVALID_PARAMETERS',
        message: 'Geometry must have at least one vertex',
      });
    }

    // Check face indices validity
    for (const face of geometry.faces) {
      for (const index of face) {
        if (index < 0 || index >= geometry.vertices.length) {
          return error({
            type: 'INVALID_PARAMETERS',
            message: `Face index ${index} is out of bounds for ${geometry.vertices.length} vertices`,
          });
        }
      }
    }

    // Check normals count matches vertices
    if (geometry.normals.length !== geometry.vertices.length) {
      return error({
        type: 'INVALID_PARAMETERS',
        message: `Normal count (${geometry.normals.length}) must match vertex count (${geometry.vertices.length})`,
      });
    }

    return success(undefined);
  }
}
