/**
 * AST Structure Debug Test
 *
 * This test file is designed to investigate the exact AST structure
 * generated by the OpenSCAD parser for the problematic code that
 * generates "unknown cylinder" errors.
 */

import { afterEach, beforeEach, describe, expect, it } from 'vitest';
import { createLogger } from '../../../shared/services/logger.service.js';

const logger = createLogger('ASTStructureDebugTest');

describe('AST Structure Debug', () => {
  let parserService: UnifiedParserService;

  beforeEach(async () => {
    logger.init('Setting up AST structure debug test environment');
    parserService = new UnifiedParserService();
    await parserService.initialize();
  });

  afterEach(async () => {
    logger.end('Cleaning up AST structure debug test environment');
    if (parserService) {
      await parserService.dispose();
    }
  });

  it('should analyze the problematic OpenSCAD code AST structure', async () => {
    const problematicCode = `translate([-24,0,0]) {
    union() {
        cube(15, center=true);
        sphere(10);
    }
}

intersection() {
    cube(15, center=true);
    sphere(10);
}

translate([24,0,0]) {
    difference() {
        cube(15, center=true);
        sphere(10);
    }
}`;

    logger.debug('Testing problematic OpenSCAD code');
    logger.debug('Code to parse:', problematicCode);

    const parseResult = await parserService.parseDocument(problematicCode);

    expect(parseResult.success).toBe(true);

    if (parseResult.success) {
      const result = parseResult.data;
      const ast = result.ast;
      logger.debug('AST parsing successful');
      logger.debug('Number of top-level nodes:', ast?.length || 0);

      // Log the complete AST structure
      if (ast) {
        ast.forEach((node, index) => {
          logger.debug(`Node ${index}:`, {
            type: node.type,
            hasChildren: 'children' in node,
            childrenCount: 'children' in node ? node.children?.length || 0 : 'N/A',
            nodeStructure: JSON.stringify(node, null, 2),
          });

          // Special analysis for translate nodes
          if (node.type === 'translate') {
            logger.debug(`Translate node ${index} detailed analysis:`, {
              hasChildren: 'children' in node,
              children: 'children' in node ? node.children : 'No children property',
              hasV: 'v' in node,
              v: 'v' in node ? node.v : 'No v property',
              allProperties: Object.keys(node),
            });
          }

          // Special analysis for boolean operation nodes
          if (['union', 'intersection', 'difference'].includes(node.type)) {
            logger.debug(`Boolean operation node ${index} (${node.type}) detailed analysis:`, {
              hasChildren: 'children' in node,
              children: 'children' in node ? node.children : 'No children property',
              allProperties: Object.keys(node),
            });
          }
        });
      } else {
        logger.debug('No AST nodes found');
      }
    } else {
      logger.error('AST parsing failed:', parseResult.error);
    }
  });

  it('should analyze simple translate node structure', async () => {
    const simpleTranslateCode = `translate([10, 20, 30]) {
    cube([5, 5, 5]);
}`;

    logger.debug('Testing simple translate code');
    const parseResult = await parserService.parseDocument(simpleTranslateCode);

    expect(parseResult.success).toBe(true);

    if (parseResult.success) {
      const result = parseResult.data;
      logger.debug('Simple translate AST structure:', JSON.stringify(result.ast, null, 2));
    }
  });

  it('should analyze simple union node structure', async () => {
    const simpleUnionCode = `union() {
    cube([5, 5, 5]);
    sphere(3);
}`;

    logger.debug('Testing simple union code');
    const parseResult = await parserService.parseDocument(simpleUnionCode);

    expect(parseResult.success).toBe(true);

    if (parseResult.success) {
      const result = parseResult.data;
      logger.debug('Simple union AST structure:', JSON.stringify(result.ast, null, 2));

      // Check if union node has children
      const unionNode = result.ast?.[0];
      if (unionNode && unionNode.type === 'union') {
        logger.debug('Union node children count:', unionNode.children?.length || 0);
        if (unionNode.children && unionNode.children.length > 0) {
          unionNode.children.forEach((child, index) => {
            logger.debug(`Union child ${index}:`, {
              type: child.type,
              properties: Object.keys(child),
            });
          });
        } else {
          logger.warn('Union node has no children - this indicates a parser issue');
        }
      }
    }
  });

  it('should test AST restructuring on problematic code', async () => {
    const problematicCode = `union() {
    cube(15, center=true);
    sphere(10);
}`;

    logger.debug('Testing AST restructuring on union code');
    const parseResult = await parserService.parseDocument(problematicCode);

    expect(parseResult.success).toBe(true);

    if (parseResult.success) {
      const result = parseResult.data;
      const rawAST = result.ast;

      logger.debug('Raw AST before restructuring:', JSON.stringify(rawAST, null, 2));

      // Import and test AST restructuring
      const { restructureAST } = await import('../services/ast-restructuring-service.js');

      const restructureResult = restructureAST(rawAST || [], {
        enableLogging: true,
        enableSourceLocationAnalysis: true,
      });

      if (restructureResult.success) {
        logger.debug('Restructured AST:', JSON.stringify(restructureResult.data, null, 2));

        const unionNode = restructureResult.data[0];
        if (unionNode && unionNode.type === 'union') {
          logger.debug(
            'After restructuring - Union node children count:',
            unionNode.children?.length || 0
          );
        }
      } else {
        logger.error('AST restructuring failed:', restructureResult.error);
      }
    }
  });
});
